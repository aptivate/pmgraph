package org.aptivate.bmotools.pmgraph;

import java.awt.Color;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;

import org.apache.log4j.Logger;

/**
 * Abstract class to store the results from the database and contains associated methods
 * to operate on this data. This is subclassed by IpDataPoint and PortDataPoint.
 * 
 * @author Noe Rodriguez
 * 
 */

public abstract class DataPoint
{

	public static final int OTHER_PORT = -1;

	private Timestamp m_time;

	private Long m_downloaded;

	private Long m_uploaded;

	abstract public String getId();

	abstract public String getSeriesId();

	abstract public Color getSeriesColor();

	abstract public DataPoint createCopy();

	private Logger m_logger = Logger.getLogger(DataPoint.class.getName());

	public DataPoint(ResultSet rs, boolean isChart) throws SQLException, IOException {
		if (isChart)
		{
			if(Configuration.getJdbcDriver().equals("org.sqlite.JDBC"))
			{
				setTime(Timestamp.valueOf(rs.getString("stamp_inserted")));
			}
			else
			{
				setTime(rs.getTimestamp("stamp_inserted"));
			}
		}
		setDownloaded(rs.getLong("downloaded"));
		setUploaded(rs.getLong("uploaded"));
	}

	public DataPoint(DataPoint source) {
		m_time = source.m_time;
		m_downloaded = source.m_downloaded;
		m_uploaded = source.m_uploaded;

	}

	public DataPoint() {
		m_downloaded = 0L;
		m_uploaded = 0L;
	}

	public Long getDownloaded()
	{
		return m_downloaded;
	}

	public void setDownloaded(Long downloaded)
	{
		this.m_downloaded = downloaded;
	}

	public Timestamp getTime()
	{
		return m_time;
	}

	public void setTime(Timestamp time)
	{
		this.m_time = time;
	}

	public Long getUploaded()
	{
		return m_uploaded;
	}

	public void setUploaded(Long uploaded)
	{
		this.m_uploaded = uploaded;
	}

	public void addToUploaded(Long uploaded)
	{
		this.m_uploaded += uploaded;
	}

	public void addToDownloaded(Long downloaded)
	{
		this.m_downloaded += downloaded;
	}

	public Long getBytesTotal()
	{
		return m_uploaded + m_downloaded;
	}

	/**
	 * The different colours for the IPs or ports are generated by this code
	 * which uses the algorithm SHA1 to generate random numbers which are used to 
	 * get distinct colours
	 * 
	 * @param bytes Byte array from Ip or port
	 * @return a distinct color
	 */
	protected Color getColorFromByteArray(byte[] bytes)
	{
		MessageDigest algorithm;
		try
		{
			algorithm = MessageDigest.getInstance("SHA1");
			algorithm.reset();
			algorithm.update(bytes);
			byte sha1[] = algorithm.digest();
			return (new Color(sha1[0] & 0xFF, sha1[1] & 0xFF, sha1[2] & 0xFF));
		} catch (NoSuchAlgorithmException e)
		{
			m_logger.error(e.getMessage(), e);
		}
		return (Color.BLACK);
	}

	/**
	 * Converts the color to a hexadecimal
	 * @return colour as a hexadecimal
	 */
	public String getColorAsHexadecimal()
	{
		Color c = getSeriesColor();
		String fillColour = Integer.toHexString(c.getRGB() & 0x00ffffff);
		return fillColour = "#"
				+ "000000".substring(0, 6 - fillColour.length()) + fillColour;
	}

	/**
	 * Two port objects are equal if they have the same port and protocol
	 * Two IP objects are equal if they have the same IP 
	 *
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	@Override
	public boolean equals(Object obj)
	{

		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;

		final DataPoint other = (DataPoint) obj;

		//Check time matches
		if (m_time == null)
		{
			if (other.getTime() != null)
				return false;
		} else
			if (!m_time.equals(other.getTime()))
				return false;
		//Check seriesId matches
		if (getSeriesId() == null)
		{
			if (other.getSeriesId() != null)
				return false;
		} else
			if (!getSeriesId().equals(other.getSeriesId()))
				return false;
		return true;
	}

	/**
	 * hashCode is the method used to assign a position in a hashMap. This
	 * object is going to be used to index hashMap so we need to implement this
	 * method. This method uses getSeriesId, which is an abstract method that is
	 * implemented in the child classes. Therefore, when you have an instance of
	 * one of the specific child classes the getSeriesId executed will be the one
	 * implemented in the specific classes.
	 * 
	 *  @see java.lang.Object#hashCode()
	 */
	@Override
	public int hashCode()
	{
		final int PRIME = 31;
		int result = 1;
		result = PRIME * result
				+ ((getSeriesId() == null) ? 0 : getSeriesId().hashCode()) + 
				((m_time == null) ? 0 : m_time.hashCode());
		return result;
	}

}
